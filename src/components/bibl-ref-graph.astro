
<div class="lgrid gap-3 lg:p-10 p-3 border rounded-lg bg-brand-50 shadow-2xl">
  <div class="text-brand-700 prose">
    <h2 class="text-2xl font-semibold mb-4 text-brand-950">Biblical References Network</h2>
    <p>This network visualises the connections between Biblical references — arranged in canonical order along the outer perimeter — and the medieval works — positioned inside the circle — in which these passages are cited. Works are classified by literary genre; clicking a genre in the legend highlights the corresponding nodes. Selecting a node navigates to the detail page of the respective work or Biblical passage.</p>
  </div>
    <div
        id="bibl-graph"
        class="w-full h-svh"
    >
  </div>
</div>

<script>
  import * as echarts from "echarts";
  import { withBasePath } from "../lib/withBasePath";
  import { generateBiblicalSortKey, extractBookAbbreviation } from "scripts/sort-bibl-ref.js";
  import biblref from "@/content/data/biblical_references.json";


document.addEventListener("DOMContentLoaded", () => {
  const chartElement = document.getElementById("bibl-graph");
  if (!chartElement) return;

  const chart = echarts.init(chartElement);
  chart.showLoading();

  

  const worksMap = new Map();
  const nodes = new Map();
  const links: any[] = [];
  // collect genres when looping over works, for legend and colors
  const genres = new Set<string>();
// to collect book of the bible for assigning them color later
    const uniqueBooks: any[] = [];
   

  // -------------------------
  // BUILD DATA
  // -------------------------

  for (const ref of biblref) {
    const sort_id = generateBiblicalSortKey(ref.name)
    const book = extractBookAbbreviation(ref.name)
     if (!uniqueBooks.includes(book)) {
    uniqueBooks.push(book);
  }
    nodes.set(ref.jad_id, {
      id: ref.jad_id,
      sort_id: sort_id,
      name: ref.name,
      book: book,
      type: 'ref',
      symbolSize: 40,
      value: ref.name,
      category: "Biblical reference",
    });

    for (const passage of ref.related_passages ?? []) {
      for (const work of passage.work ?? []) {
        const genre = work.genre || "Unknown";

        if (!worksMap.has(work.jad_id)) {
          worksMap.set(work.jad_id, work);

          genres.add(genre);

          nodes.set(work.jad_id, {
            id: work.jad_id,
            name: `${work.author[0].name}: ${work.title}`,
            category: genre,
            symbolSize: 20,
            value: work.title,
            type: 'work',
          });
        }

        links.push({
          source: ref.jad_id,
          target: work.jad_id,
          name: `${ref.name} -> ${work.author[0].name}: ${work.title}`
        });
      }
    }
  }
  const refNodes = [];
  const workNodes = [];
  for (const node of nodes.values()) {
    if (node.type === "ref") {
      refNodes.push(node);
    } else {
      workNodes.push(node);
    }
  }
// custom coloring for single bible books
const bookColorMap = new Map();
uniqueBooks.forEach((book, index) => {
  const lightness = 15 + Math.round((45 / uniqueBooks.length) * index); // range 35–65%
  bookColorMap.set(book, `hsl(13, 83.3%, ${lightness}%)`); // cool grey-blue
});
      
// postitioning. make a circle
const width = chart.getWidth();
const height = chart.getHeight();

const centerX = width / 2;
const centerY = height / 2;
const radius = Math.min(width, height) * 0.42;



//  position the ref nodes on the perifery
refNodes
.sort(function(a,b,) {
    return parseFloat(a.sort_id) - parseFloat(b.sort_id)
})
.forEach((node, i) => {
  const angle = (2 * Math.PI * i) / refNodes.length;

  node.x = centerX + radius * Math.cos(angle);
  node.y = centerY + radius * Math.sin(angle);
  node.symbolSize = 14;
  node.label = { show: false };
  node.itemStyle = {
  color: bookColorMap.get(node.book)
};
});

// position works inside the circle spread ---
workNodes.forEach(node => {
  const r = radius * 0.85 * Math.sqrt(Math.random());
  const theta = Math.random() * 2 * Math.PI;

  node.x = centerX + r * Math.cos(theta);
  node.y = centerY + r * Math.sin(theta);
  node.symbolSize = 8;
  node.label = { show: false };
});


  
  //  genres categories for legend
const genreArray = Array.from(genres);
 const categories = [
  { name: "Biblical reference" },
 ...genreArray.map((genre, index) => ({
    name: genre,
    itemStyle: {
      color: generateColor(index, genreArray.length)
    }
  }))
];
const categoryIndexMap = new Map();
categories.forEach((c, i) => {
  categoryIndexMap.set(c.name, i);
});



for (const node of nodes.values()) {
  const idx = categoryIndexMap.get(node.category);
  if (idx === undefined) {
    console.log("Missing category for:", node.name);
  } else {
    node.category = idx;
  }
}

  chart.hideLoading();

  // set the echart options

  const option = {
    title: {
      text: "Biblical References and Works",
            left: "center",
            top: 20,
            textStyle: {
                fontSize: 24,
                fontWeight: "bold",
                color: "#333",
            }, 
    },
    tooltip: {
      trigger: "item",
            textStyle: { fontSize: 12 },
            formatter: function (params: any) {
            return `<strong>${params.data.name}</strong><br/>
                    `;
            },
    },
  backgroundColor: "#f5f3f0",
  

  legend: {
    
    bottom: 10,
     data: genreArray,
    selectedMode: 'multiple',
    hoverLink: false
  },

  series: [{
    type: "graph",
    layout: "none",

    roam: true,
    draggable: false,

    data: [...refNodes, ...workNodes],
    links: links,
    categories: categories,

    edgeSymbol: ["none", "none"],

    lineStyle: {
      color: "#999",
      width: 0.8,
      opacity: 0.25,
      curveness: 0.15
    },    
    label: {
      show: false,
      position: "right",
      fontSize: 11
    },
    
  }],
    toolbox: {
            show: true,
            orient: "vertical",
            right: 30,
            top: 20,
            itemSize: 20,
            itemGap: 20,
            feature: {
            saveAsImage: {
                show: true,
                title: "Download as PNG",
                type: "png",
                pixelRatio: 2,
                backgroundColor: "#fff",
            },
            },
        },
};

chart.setOption(option);
// hover and emphasis doenst work properly with legend 
// custom event listener for hover

chart.on("mouseover", function (params) {
  if (params.dataType !== "node") return;

  const option = chart.getOption() as any;
  const nodes = option.series[0].data;
  const links = option.series[0].links;

  const nodeId = (params.data as any).id;
  const connected = new Set();
  connected.add(nodeId);

  links.forEach((link: any) => {
    if (link.source === nodeId) connected.add(link.target);
    if (link.target === nodeId) connected.add(link.source);
  });

  nodes.forEach((node: any) => {
    const isConnected = connected.has(node.id);
    node.label = { show: isConnected };
    node.itemStyle = { ...node.itemStyle, opacity: isConnected ? 1 : 0.2 };
  });

  links.forEach((link: any) => {
    const isConnected = link.source === nodeId || link.target === nodeId;
    link.lineStyle = { ...link.lineStyle, opacity: isConnected ? 0.8 : 0.05 };
  });

  chart.setOption(option);
});

chart.on("mouseout", function () {
  const option = chart.getOption() as any;
  const nodes = option.series[0].data;
  const links = option.series[0].links;

  nodes.forEach((node: any) => {
    node.label = { show: false };
    node.itemStyle = { ...node.itemStyle, opacity: 1 };
  });

  links.forEach((link: any) => {
    link.lineStyle = { ...link.lineStyle, opacity: 0.25 };
  });

  chart.setOption(option);
});

// control legend behavior, on click
let activeCategory: any = null; // track which category is highlighted

chart.on("legendselectchanged", function (params: any) {
  const clickedCategory = params.name;

  // Re-select the legend item so ECharts doesn't hide the nodes
  chart.dispatchAction({
    type: "legendSelect",
    name: clickedCategory
  });

  // Toggle: clicking the same category again clears the highlight
  if (activeCategory === clickedCategory) {
    activeCategory = null;
  } else {
    activeCategory = clickedCategory;
  }

  setTimeout(() => {
    const option: any = chart.getOption();
    const nodes = option.series[0].data;

    nodes.forEach((node: any) => {
      const categoryName = categories[node.category]?.name;

      if (activeCategory === null) {
        // Nothing selected — hide all labels
        node.label = { show: false };
         node.itemStyle = { ...node.itemStyle, opacity: 1 }; 
      } else {
        // Show labels only for nodes in the active category
        const isActive = categoryName === activeCategory;
    node.label = { show: isActive };
    node.itemStyle = { ...node.itemStyle, opacity: isActive ? 1 : 0.5 }; // preserve color
  }
    });

    chart.setOption(option);
  }, 0);
});


  window.addEventListener("resize", () => chart.resize());

  // Add click handler to link to search results for the genre
    chart.on("click", function (params: any) {
      if (params.data.type === 'ref') {
        window.location.href = withBasePath(
          `/biblical-refs/${params.data.id}`
        );
      }
      if (params.data.type === 'work'){
        window.location.href = withBasePath(
          `/works/${params.data.id}`
        );
      }
    });

    
});

function generateColor(index : number, total: number) {
  const hue = Math.round((360 / total) * index);
  return `hsl(${hue}, 55%, 40%)`;
}




</script>