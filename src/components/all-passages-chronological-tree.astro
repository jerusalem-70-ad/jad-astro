---
---

<div id="d3-timeline" style="width: 100%; height: 600px;"></div>

<script>
    import * as d3 from "d3";
    import passages from "@/content/data/passages.json";

  // Test data first - replace with actual passages import later
  const testPassages = passages;

    document.addEventListener("DOMContentLoaded", () => {
    const container = document.getElementById("d3-timeline");
    if (!container) return;

    // Clear any existing content
    d3.select(container).selectAll("*").remove();

    // Collect all nodes and links from all passages
    const allNodes = [];
    const allLinks = [];
    const nodeMap = new Map(); // Track nodes by ID to avoid duplicates

    testPassages.forEach(passage => {
      if (passage.transmission_graph?.graph?.nodes) {
        passage.transmission_graph.graph.nodes.forEach(node => {
          if (!nodeMap.has(node.id)) {
            allNodes.push({
              ...node,
              sourcePassage: passage.passage,
              x: Math.random() * 600 + 100, // Initial random X position
              y: 0, // Will be set based on date
            });
            nodeMap.set(node.id, allNodes.length - 1);
          }
        });

        if (passage.transmission_graph.graph.links) {
          passage.transmission_graph.graph.links.forEach(link => {
            allLinks.push({
              source: link.source,
              target: link.target,
            });
          });
        }
      }
    });

    console.log("D3 Data:", { nodes: allNodes, links: allLinks });

    // Set up dimensions and margins - make it bigger and use full width
    const margin = { top: 50, right: 50, bottom: 50, left: 80 };
    const containerWidth = container.clientWidth;
    const width = containerWidth - margin.left - margin.right;
    const height = 800 - margin.top - margin.bottom; // Taller for better spacing

    // Create SVG
    const svg = d3
      .select(container)
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom);

    const g = svg
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create scales
    const dates = allNodes.map(d => d.date);
    const yScale = d3
      .scaleLinear()
      .domain(d3.extent(dates))
      .range([height, 0]); // Invert Y scale (older dates at top)

    const xScale = d3
      .scaleLinear()
      .domain([0, width])
      .range([0, width]);

    // Add Y axis
    g.append("g")
      .call(d3.axisLeft(yScale).tickFormat(d3.format("d")))
      .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", -60)
      .attr("x", -height / 2)
      .attr("text-anchor", "middle")
      .style("font-size", "14px")
      .style("fill", "black")
      .text("Year");

    // Position nodes based on date (Y) - X will be handled by force simulation
    allNodes.forEach(node => {
      node.y = yScale(node.date);
      node.fx = null; // Allow X movement
      node.fy = node.y; // Fix Y position based on date
    });

    // Create force simulation for X positioning and collision detection
    const simulation = d3.forceSimulation(allNodes)
      .force("x", d3.forceX(width / 2).strength(0.1)) // Gentle centering force
      .force("collide", d3.forceCollide().radius(12).strength(0.7)) // Prevent overlap
      .force("charge", d3.forceManyBody().strength(-50)) // Slight repulsion
      .alphaDecay(0.02) // Slower cooling for better settling
      .on("tick", updatePositions);

    // Create node and link selections
    const link = g
      .append("g")
      .selectAll("line")
      .data(allLinks)
      .join("line")
      .attr("stroke", "#999")
      .attr("stroke-width", 2)
      .attr("opacity", 0.6);

    // Track selection state
    let selectedNodeId = null;
    let connectedNodeIds = new Set();

    // Function to get connected node IDs
    function getConnectedNodes(nodeId) {
      const connected = new Set();
      allLinks.forEach(link => {
        if (link.source === nodeId) {
          connected.add(link.target);
        }
        if (link.target === nodeId) {
          connected.add(link.source);
        }
      });
      return connected;
    }

    // Function to update node colors based on selection
    function updateNodeColors() {
      node.attr("fill", d => {
        if (selectedNodeId === null) {
          return "#3498db"; // Default blue when nothing selected
        } else if (d.id === selectedNodeId) {
          return "#e74c3c"; // Red for selected node
        } else if (connectedNodeIds.has(d.id)) {
          return "#f39c12"; // Orange for connected nodes
        } else {
          return "#bdd6f0"; // Very pale blue for unrelated nodes
        }
      });
    }

    // Function to update link styles based on selection
    function updateLinkStyles() {
      link
        .attr("stroke", d => {
          if (selectedNodeId !== null && (d.source === selectedNodeId || d.target === selectedNodeId)) {
            return "#000"; // Black for edges connected to selected node
          } else {
            return "#999"; // Default gray
          }
        })
        .attr("stroke-width", d => {
          if (selectedNodeId !== null && (d.source === selectedNodeId || d.target === selectedNodeId)) {
            return 3; // Thicker for connected edges
          } else {
            return 2; // Default width
          }
        })
        .attr("opacity", d => {
          if (selectedNodeId === null) {
            return 0.6; // Default opacity
          } else if (d.source === selectedNodeId || d.target === selectedNodeId) {
            return 0.9; // More visible for connected edges
          } else {
            return 0.3; // More faded for unrelated edges
          }
        });
    }

    const node = g
      .append("g")
      .selectAll("circle")
      .data(allNodes)
      .join("circle")
      .attr("r", 6)
      .attr("fill", "#3498db") // Initial blue color for all nodes
      .attr("stroke", "#2c3e50")
      .attr("stroke-width", 1)
      .style("cursor", "pointer") // Show it's clickable
      .on("click", function(event, d) {
        event.stopPropagation(); // Prevent event bubbling
        
        if (selectedNodeId === d.id) {
          // If clicking the same node, deselect
          selectedNodeId = null;
          connectedNodeIds.clear();
        } else {
          // Select new node and find connected nodes
          selectedNodeId = d.id;
          connectedNodeIds = getConnectedNodes(d.id);
        }
        
        updateNodeColors();
        updateLinkStyles(); // Also update link styles
        console.log(`Selected node: ${selectedNodeId}, Connected: [${Array.from(connectedNodeIds).join(', ')}]`);
      });

    // Add tooltips
    node.append("title")
      .text(d => `${d.name}\nDate: ${d.date}\nType: ${d.nodeType}\nClick to highlight connections`);

    // Update positions (called by force simulation)
    function updatePositions() {
      // Update link positions
      link
        .attr("x1", d => {
          const sourceNode = allNodes.find(n => n.id === d.source);
          return sourceNode ? sourceNode.x : 0;
        })
        .attr("y1", d => {
          const sourceNode = allNodes.find(n => n.id === d.source);
          return sourceNode ? sourceNode.y : 0;
        })
        .attr("x2", d => {
          const targetNode = allNodes.find(n => n.id === d.target);
          return targetNode ? targetNode.x : 0;
        })
        .attr("y2", d => {
          const targetNode = allNodes.find(n => n.id === d.target);
          return targetNode ? targetNode.y : 0;
        });

      // Update node positions
      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
    }

    // Add drag behavior 
    const drag = d3.drag()
      .on("start", function(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y; // Keep Y fixed even when dragging
      })
      .on("drag", function(event, d) {
        d.fx = event.x;
        d.fy = yScale(d.date); // Always maintain date-based Y position
      })
      .on("end", function(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null; // Release X constraint
        d.fy = yScale(d.date); // Keep Y constraint
      });

    // Add click handler to SVG background to deselect
    svg.on("click", function(event) {
      // Only deselect if clicking on background (not on nodes)
      if (event.target === this || event.target.tagName === 'rect') {
        selectedNodeId = null;
        connectedNodeIds.clear();
        updateNodeColors();
        updateLinkStyles(); // Reset link styles too
      }
    });

    node.call(drag);

    console.log("D3 visualization created successfully");
  });
</script>